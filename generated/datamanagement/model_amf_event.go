// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Nnwdaf_DataManagement
 *
 * Nnwdaf_DataManagement API Service.   Â© 2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved. 
 *
 * API version: 1.0.3
 */

package datamanagement


import (
	"time"
)



// AmfEvent - Describes an event to be subscribed
type AmfEvent struct {

	Type AmfEventType `json:"type"`

	ImmediateFlag bool `json:"immediateFlag,omitempty"`

	AreaList []AmfEventArea `json:"areaList,omitempty"`

	LocationFilterList []LocationFilter `json:"locationFilterList,omitempty"`

	RefId int32 `json:"refId,omitempty"`

	TrafficDescriptorList []TrafficDescriptor `json:"trafficDescriptorList,omitempty"`

	ReportUeReachable bool `json:"reportUeReachable,omitempty"`

	ReachabilityFilter ReachabilityFilter `json:"reachabilityFilter,omitempty"`

	UdmDetectInd bool `json:"udmDetectInd,omitempty"`

	MaxReports int32 `json:"maxReports,omitempty"`

	// A map(list of key-value pairs) where praId serves as key.
	PresenceInfoList map[string]PresenceInfo `json:"presenceInfoList,omitempty"`

	// indicating a time in seconds.
	MaxResponseTime int32 `json:"maxResponseTime,omitempty"`

	TargetArea TargetArea `json:"targetArea,omitempty"`

	SnssaiFilter []ExtSnssai `json:"snssaiFilter,omitempty"`

	UeInAreaFilter UeInAreaFilter `json:"ueInAreaFilter,omitempty"`

	// indicating a time in seconds.
	MinInterval int32 `json:"minInterval,omitempty"`

	// string with format 'date-time' as defined in OpenAPI.
	NextReport time.Time `json:"nextReport,omitempty"`

	IdleStatusInd bool `json:"idleStatusInd,omitempty"`

	DispersionArea DispersionArea `json:"dispersionArea,omitempty"`

	// string with format 'date-time' as defined in OpenAPI.
	NextPeriodicReportTime time.Time `json:"nextPeriodicReportTime,omitempty"`
}

// AssertAmfEventRequired checks if the required fields are not zero-ed
func AssertAmfEventRequired(obj AmfEvent) error {
	elements := map[string]interface{}{
		"type": obj.Type,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertAmfEventTypeRequired(obj.Type); err != nil {
		return err
	}
	for _, el := range obj.AreaList {
		if err := AssertAmfEventAreaRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.LocationFilterList {
		if err := AssertLocationFilterRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.TrafficDescriptorList {
		if err := AssertTrafficDescriptorRequired(el); err != nil {
			return err
		}
	}
	if err := AssertReachabilityFilterRequired(obj.ReachabilityFilter); err != nil {
		return err
	}
	if err := AssertTargetAreaRequired(obj.TargetArea); err != nil {
		return err
	}
	for _, el := range obj.SnssaiFilter {
		if err := AssertExtSnssaiRequired(el); err != nil {
			return err
		}
	}
	if err := AssertUeInAreaFilterRequired(obj.UeInAreaFilter); err != nil {
		return err
	}
	if err := AssertDispersionAreaRequired(obj.DispersionArea); err != nil {
		return err
	}
	return nil
}

// AssertAmfEventConstraints checks if the values respects the defined constraints
func AssertAmfEventConstraints(obj AmfEvent) error {
	if err := AssertAmfEventTypeConstraints(obj.Type); err != nil {
		return err
	}
	for _, el := range obj.AreaList {
		if err := AssertAmfEventAreaConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.LocationFilterList {
		if err := AssertLocationFilterConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.TrafficDescriptorList {
		if err := AssertTrafficDescriptorConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertReachabilityFilterConstraints(obj.ReachabilityFilter); err != nil {
		return err
	}
	if err := AssertTargetAreaConstraints(obj.TargetArea); err != nil {
		return err
	}
	for _, el := range obj.SnssaiFilter {
		if err := AssertExtSnssaiConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertUeInAreaFilterConstraints(obj.UeInAreaFilter); err != nil {
		return err
	}
	if err := AssertDispersionAreaConstraints(obj.DispersionArea); err != nil {
		return err
	}
	return nil
}
